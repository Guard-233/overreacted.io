---
title: 我对热重载的愿望清单
date: "2018-12-08"
spoiler: 圣诞节我想要的并不多。我只需要一样东西。
---

你是否有一个项目，你反复尝试，有成功也有失败，然后搁置一段时间，接着年复一年地再次尝试？对某些人来说，这可能是路由器或虚拟列表滚动器。对我来说，这是热重载。

我第一次接触到动态修改代码的想法，是在我十几岁时读到的一本关于 Erlang 的书中简短提及。很久以后，像许多人一样，我爱上了 [Bret Victor 精彩的演示](https://vimeo.com/36579366)。我曾在某处读到，Bret 对人们断章取义地采用他演示中“简单”的部分并搞砸了宏伟的愿景感到不满。（我不知道这是否属实。）**无论如何，对我来说，即使是发布那些人们日后习以为常的微小增量改进，也是一种成功。** 比我更聪明的人会致力于下一个宏大理念。

现在，我想明确指出，这篇文章中讨论的任何*想法*都不是我的。我受到了许多项目和人的[启发](https://redux.js.org/introduction/prior-art)。事实上，即使是那些我从未尝试过他们项目的人，有时也会告诉我我抄袭了他们的东西。

我不是一个发明家。如果我有一个“原则”，那就是将一个激励我的愿景，通过文字、代码和演示，分享给更多人。

而热重载激励着我。

---

我曾多次尝试为 React 实现热重载。

回想起来，我拼凑出的[第一个演示](https://vimeo.com/100010922)改变了我的生活。它为我带来了第一个 Twitter 关注者，第一个 GitHub 千星项目，后来是第一个 [HN 首页](https://news.ycombinator.com/item?id=8982620)热门，甚至我的第一次[会议演讲](https://www.youtube.com/watch?v=xsSnOQynTHs)（哎呀，还催生了 Redux）。第一次迭代效果相当好。然而，不久之后 React *不再*使用 `createClass`，这使得可靠的实现变得更加困难。

从那时起，我又做了[几次尝试](https://medium.com/@dan_abramov/hot-reloading-in-react-1140438583bf?source=user_profile---------6------------------)来修复它，每一次都有不同的缺陷。其中一个仍在 React Native 中使用（由于我的错误，热重载函数在那里不起作用——抱歉！）

由于我无法解决某些问题以及缺乏时间而感到沮丧，我将 React Hot Loader 交给了几位才华横溢的贡献者。他们一直在推动项目前进，并为我的设计缺陷找到了巧妙的解决方法。我感谢他们尽管面临挑战，仍将项目维持在良好状态。

---

**需要明确的是，React 中的热重载如今相当可用。** 事实上，这个博客使用了 Gatsby，而 Gatsby 底层使用了 React Hot Loader。我在编辑器中保存这篇文章，它无需刷新即可更新。魔法！在某些方面，我曾担心永远不会被主流使用的愿景，现在已经几乎变得乏善可陈。

但是有很多人觉得它没有达到应有的水平。有些人认为它只是个噱头而不屑一顾，这让我有点心碎，但我认为他们真正想说的是：**体验并非无缝。** 如果你永远不确定热重载是否有效，如果它以令人困惑的方式中断，或者如果刷新一下更容易，那么它就不值得。我 100% 同意这一点，但对我来说，这意味着我们还有更多工作要做。我很兴奋开始思考未来 React 对热重载的官方支持会是什么样子。

（如果你使用像 Elm、Reason 或 ClojureScript 这样的语言，也许这些问题在你的生态系统中已经解决了。我为你感到高兴。但这不会阻止我尝试并失败地将好东西带到 JavaScript 中。）

---

我想我已经准备好再次尝试实现它了。原因如下。

自从 `createClass` 不再是我们定义组件的主要方式以来，**热重载组件中复杂性和脆弱性的最大来源是动态替换类方法。** 你如何用新“版本”的方法来修补现有的类实例？简单的答案是“在原型上替换它们”，但根据我的经验，即使使用 Proxies，也有太多棘手的边缘情况导致这种方法无法可靠工作。

相比之下，热重载函数很容易。一个 Babel 插件可以将任何从模块导出的函数组件分割成两个函数：

```jsx
// 重新赋值最新版本
window.latest_Button = function (props) {
  // 你的实际代码被插件移到这里
  return <button>Hello</button>;
};

// 将此视为一个“代理”
// 其他组件会使用它
export default function Button(props) {
  // 总是指向最新版本
  return window.latest_Button(props);
}
```

每当这个模块在编辑后重新执行时，`window.latest_Button` 就会指向最新的实现。在模块评估之间重用相同的 `Button` 函数，可以让我们欺骗 React 不卸载我们的组件，即使我们已经替换了实现。

在很长一段时间里，我似乎觉得仅仅为函数实现可靠的热重载会鼓励人们编写复杂的代码来避免使用类。但是有了 [Hooks](https://reactjs.org/docs/hooks-intro.html)，函数组件功能齐全，所以这不再是一个问题。而且这种方法对 Hooks “就是能用”：

```jsx {4}
// 重新赋值最新版本
window.latest_Button = function (props) {
  // 你的实际代码被插件移到这里
  const [name, setName] = useState("Mary");
  const handleChange = (e) => setName(e.target.value);
  return (
    <>
      <input value={name} onChange={handleChange} />
      <h1>Hello, {name}</h1>
    </>
  );
};

// 将此视为一个“代理”
// 其他组件会使用它
export default function Button(props) {
  // 总是指向最新版本
  return window.latest_Button(props);
}
```

只要 Hook 的调用顺序不变，即使 `window.latest_Button` 在文件编辑之间被替换，我们也可以保留状态。并且替换事件处理程序也“就是能用”——因为 Hooks 依赖于闭包，而我们替换了整个函数。

---

这只是一个可能方法的大致草图。还有更多（有些非常不同）。我们如何评估和比较它们？

在我过于执着于某个可能有缺陷的具体方法之前，**我决定写下一些我认为对于评判任何组件代码的热重载实现都很重要的原则。**

以后能将其中一些原则表达为测试就好了。这些规则并不严格，可能存在合理的妥协。但如果我们决定打破它们，那应该是一个明确的设计决策，而不是我们后来偶然发现的事情。

以下是我对 React 组件热重载的愿望清单：

### 正确性 (Correctness)

- **在首次编辑前，热重载应该是无法察觉的。** 在你保存文件之前，代码的行为应该与禁用热重载时完全一样。像 `fn.toString()` 不匹配是预期之内的，这在代码压缩时已经是这样了。但不应破坏合理的应用程序和库逻辑。

- **热重载不应破坏 React 规则。** 组件的生命周期不应以意想不到的方式被调用，不应意外地在不相关的树之间交换状态，或者做其他非 React 的事情。

- **元素类型应始终与预期类型匹配。** 有些方法会包装组件类型，但这可能破坏 `<MyThing />.type === MyThing`。这是一个常见的 bug 来源，不应该发生。

- **应该易于支持所有 React 类型。** `lazy`, `memo`, `forwardRef`——它们都应该被支持，并且添加对更多类型的支持不应该困难。嵌套变体如 `memo(memo(...))` 也应工作。当类型结构改变时，我们应该总是重新挂载。

- **它不应重新实现 React 中相当大的一部分。** 跟上 React 的步伐很难。如果一个解决方案重新实现了 React，随着 React 添加像 Suspense 这样的特性，它会在长期内带来问题。

- **重新导出不应中断。** 如果一个组件从其他模块（无论是自己的还是来自 `node_modules`）重新导出组件，这不应引起问题。

- **静态字段不应中断。** 如果你定义了一个 `ProfilePage.onEnter` 方法，你会期望导入模块能够读取它。有时库依赖于此，所以能够读写静态属性，并且组件本身能够在其自身上“看到”相同的值，这一点很重要。

- **丢失本地状态比行为不正确更好。** 如果我们无法可靠地修补某些东西（例如，一个类），那么丢失其本地状态比尝试更新它但效果混杂要好。开发者无论如何都会产生怀疑并可能强制刷新。我们应该明确哪些情况我们有信心处理，并放弃其余的。

- **丢失本地状态比使用旧版本更好。** 这是前一个原则更具体的变体。例如，如果一个类无法热重载，代码应该强制使用新版本重新挂载那些组件，而不是继续渲染一个僵尸（版本）。

### 局部性 (Locality)

- **编辑一个模块应尽可能少地重新执行模块。** 通常不鼓励在组件模块初始化期间产生副作用。但是你执行的代码越多，某些东西在被调用两次时引起混乱的可能性就越大。我们正在编写 JavaScript，React 组件是（相对）纯净的孤岛，但即使在那里我们也没有强有力的保证。所以如果我编辑一个模块，我的热重载解决方案应该重新执行该模块，并尽可能地停在那里。

- **编辑一个组件不应销毁其父级或兄弟组件的状态。** 类似于 `setState()` 只影响下面的树，编辑一个组件不应影响其上方的任何东西。

- **对非 React 代码的编辑应向上传播。** 如果你编辑了一个包含常量或纯函数的文件，并且该文件被多个组件导入，那么这些组件应该更新。丢失此类文件中的模块状态是可以接受的。

- **热重载期间引入的运行时错误不应传播。** 如果你在一个组件中犯了一个错误，它不应该破坏你的整个应用程序。在 React 中，这通常通过错误边界解决。然而，对于我们在编辑时犯下的无数拼写错误来说，它们太粗粒度了。我应该能够在我处理一个组件时产生并修复运行时错误，而不会导致其兄弟或父组件卸载。但是，那些*不是*在热重载期间发生（并且是我代码中合法 bug）的错误，应该传递给最近的错误边界。

- **保留自身状态，除非明确开发者不希望如此。** 如果你只是调整样式，每次编辑都重置状态会令人沮丧。另一方面，如果你刚刚更改了状态结构或初始状态，你通常更希望它重置。默认情况下，我们应该尽力保留状态。但如果在热重载期间导致错误，这通常表明某些假设已改变，所以我们应该在这种情况下重置状态并*重试*渲染。注释掉某些内容再取消注释是很常见的，因此优雅地处理这种情况很重要。例如，在*末尾*移除 Hook 不应重置状态。

- **在明确开发者希望重置时丢弃状态。** 在某些情况下，我们也可以主动检测用户想要重置。例如，如果 Hook 顺序改变了，或者像 `useState` 这样的原始 Hook 改变了它们的初始状态类型。我们还可以提供一个轻量级的注释，你可以用来强制组件在每次编辑时重置。比如 `// !` 或其他类似的约定，在你专注于组件如何挂载时可以快速添加和删除。

- **支持更新“固定”的东西。** 如果一个组件被 `memo()` 包裹，热重载仍然应该更新它。如果一个 effect 使用 `[]` 调用，它仍然应该被替换。代码就像一个无形的变量。以前，我认为对于像 `renderRow={this.renderRow}` 这样的东西强制进行深层更新很重要。但在 Hooks 的世界里，我们无论如何都依赖闭包，这似乎不再必要了。一个不同的引用应该就足够了。

- **支持单个文件中的多个组件。** 在同一个文件中定义多个组件是一种常见的模式。即使我们只保留函数组件的状态，我们也希望确保将它们放在一个文件中不会导致它们丢失状态。注意这些可以是相互递归的。

- **在可能的情况下，保留子组件的状态。** 如果你编辑一个组件，如果它的子组件无意中丢失了状态，总是令人沮丧。只要子组件的元素类型在其他文件中定义，我们期望它们的状态被保留。如果它们在同一个文件中，我们应该尽力而为。

- **支持自定义 Hook。** 对于写得好的自定义 Hook（像 `useInterval()` 这样的某些情况可能有点棘手），热重载任何参数（包括函数）都应该有效。这不需要额外的工作，并且源于 Hooks 的设计。我们的解决方案只是不应该妨碍。

- **支持 render props。** 这通常不会带来问题，但值得验证它们是否按预期工作和更新。

- **支持高阶组件 (HOC)。** 将导出包装到像 `connect` 这样的高阶组件中不应破坏热重载或状态保留。如果你在 JSX 中使用由 HOC 创建的组件（例如 `styled`），并且该组件是一个类，那么当它在被编辑的文件中实例化时丢失状态是预期的。但是返回函数组件（可能使用 Hooks）的 HOC 不应丢失状态，即使它在同一个文件中定义。事实上，即使对其参数（例如 `mapStateToProps`）的编辑也应被反映出来。

### 反馈 (Feedback)

- **成功和失败都应提供视觉反馈。** 你应该始终确信热重载是成功还是失败。在发生运行时或语法错误的情况下，你应该看到一个遮罩层，它应该在不再相关时自动消失。当热重载成功时，应该有一些视觉反馈，例如闪烁更新的组件或通知。

- **语法错误不应导致运行时错误或刷新。** 当你编辑代码并且有语法错误时，它应该显示在一个模态遮罩层中（理想情况下，可以点击跳转到编辑器）。如果你犯了另一个语法错误，现有的遮罩层会更新。只有在你修复了语法错误*之后*才会尝试热重载。语法错误不应让你丢失状态。

- **重载后的语法错误仍应可见。** 如果你看到一个模态语法错误遮罩层并刷新，你应该仍然能看到它。绝对不应该让你运行上一个成功的版本（我在某些设置中见过这种情况）。

- **考虑提供高级用户工具。** 通过热重载，代码本身可以成为你的“终端”。除了假设的 `// !` 命令来强制重新挂载之外，还可以有例如 `// inspect` 命令，在组件旁边显示一个包含 props 值的面板。发挥创造力！

- **最小化干扰。** 开发者工具和警告消息不应暴露我们正在做一些特殊的事情。避免破坏 `displayName` 或在调试输出中添加无用的包装器。

- **在主流浏览器中调试应显示最新的代码。** 虽然这不完全取决于我们，但我们应该尽力确保浏览器调试器显示任何文件的最新版本，并且断点按预期工作。

- **为快速迭代优化，而非长期重构。** 这是 JavaScript，不是 Elm。任何长时间的系列编辑很可能由于一堆需要逐一修复的错误而无法很好地热重载。如有疑问，应优先考虑在紧密的迭代循环中调整少数组件的用例，而不是大型重构。并且要可预测。请记住，如果你失去了开发者的信任，他们无论如何都会刷新。

---

这就是我对 React——或任何提供比模板更多功能的组件系统——中热重载应该如何工作的愿望清单。随着时间的推移，我可能会在这里添加更多东西。

我不知道用 JavaScript 我们能实现这些目标中的多少。但我期待再次致力于热重载还有一个原因。作为一名工程师，我现在比以前更有条理了。特别是，**我终于吸取了教训，在投入另一次实现之前，先像这样写下需求。**

也许这次真的能成功！但如果不行，至少我为下一个尝试的人留下了一些线索。
