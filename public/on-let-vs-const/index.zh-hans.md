---
title: 关于 let 和 const
date: "2019-12-22"
spoiler: 那么我应该用哪个呢？
---

我的[上一篇文章](/what-is-javascript-made-of/)包含了这段话：

> **`let` vs `const` vs `var`**: 通常你想要 `let`。如果你想禁止给这个变量赋值，你可以使用 `const`。（一些代码库和同事很迂腐，强制你在只赋值一次的情况下使用 `const`。）

结果这引起了很大的争议，在 Twitter 和 Reddit 上引发了讨论。似乎大多数观点（或者至少是表达最强烈的观点）是应该*尽可能使用 `const`*，只有在必要时才回退到 `let`，这可以通过 [`prefer-const`](https://eslint.org/docs/rules/prefer-const) ESLint 规则来强制执行。

在这篇文章中，我将简要总结我遇到的一些论点和反驳，以及我对这个话题的个人结论。

## 为什么倾向于 `const`

- **一种方式实现**: 每次都必须在 `let` 和 `const` 之间进行选择会增加心理负担。“只要可行就总是使用 `const`”这样的规则让你不再需要考虑这个问题，并且可以通过 linter 来强制执行。
- **重新赋值可能导致 Bug**: 在一个较长的函数中，很容易忽略变量何时被重新赋值。这可能会导致 bug。尤其是在闭包中，`const` 让你确信你总是会“看到”相同的值。
- **学习关于可变性**: JavaScript 新手经常会混淆，认为 `const` 意味着不可变性。然而，有人可能会认为，无论如何学习变量突变和赋值之间的区别很重要，而倾向于 `const` 会迫使你尽早面对这种区别。
- **无意义的赋值**: 有时，赋值根本没有意义。例如，对于 React Hooks，你从像 `useState` 这样的 Hook 中获得的值更像是参数。它们是单向流动的。看到对它们的赋值错误可以帮助你更早地了解 React 的数据流。
- **性能优势**: 有时有人声称，由于知道变量不会被重新赋值，JavaScript 引擎可以使使用 `const` 的代码运行得更快。

## 为什么不倾向于 `const`

- **意图的丢失**: 如果我们强制在所有可行的地方都使用 `const`，我们就失去了传达某些东西不被重新赋值是否*重要*的能力。
- **与不可变性的混淆**: 在每一次关于为什么应该倾向于 `const` 的讨论中，总有人会与不可变性混淆。这并不奇怪，因为赋值和突变都使用相同的 `=` 运算符。作为回应，人们通常被告知他们应该“只是学习这门语言”。然而，反驳的观点是，如果一个主要防止初学者错误的特性让初学者感到困惑，那么它就不是很有用。不幸的是，它并不能帮助防止跨模块并影响所有人的突变错误。
- **避免重新声明的压力**: 一个以 `const` 为先的代码库会产生一种压力，即对于条件赋值的变量不使用 `let`。例如，你可能会写 `const a = cond ? b : c` 而不是 `if` 条件，即使 `b` 和 `c` 分支都很复杂，并且给它们明确的名称很尴尬。
- **重新赋值可能不会导致 Bug**: 在三种常见情况下，重新赋值会导致 bug：当作用域非常大（例如模块作用域或巨大的函数）、当值是一个参数（因此它不应该等于传递进来的值之外的任何东西），以及当一个变量在嵌套函数中使用时。然而，在许多代码库中，大多数变量都不会满足这些情况中的任何一种，并且参数根本无法标记为常量。
- **没有性能优势**: 据我所知，引擎已经知道哪些变量只被赋值一次——即使你使用 `var` 或 `let`。如果我们坚持推测，我们也可以推测额外的检查可能会*增加*性能成本而不是降低它。但实际上，引擎很智能。

## 我的结论

我不在乎。

我会使用代码库中已有的任何约定。

如果你在乎，请使用一个可以自动检查和修复此问题的 linter，这样将 `let` 更改为 `const` 就不会成为代码审查的延迟。

最后，请记住，linter 的存在是为了服务*你*。如果一个 linter 规则让你和你的团队感到恼火，那就删除它。它可能不值得。从你自己的错误中学习。
