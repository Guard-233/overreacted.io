---
title: "两种 React"
date: "2024-01-04"
spoiler: "UI = f(data)(state)"
---

假设我想在你的屏幕上显示一些东西。无论我想显示像这篇博客文章一样的网页，一个交互式的 Web 应用程序，还是你可能从某个应用商店下载的本地应用程序，至少需要涉及 _两个_ 设备。

你的设备和我的设备。

它始于 _我的_ 设备上的一些代码和数据。例如，我正在我的笔记本电脑上以文件的形式编辑这篇博客文章。如果你在你的屏幕上看到它，它肯定已经从我的设备传输到了你的设备。在某个时刻，某个地方，我的代码和数据变成了 HTML 和 JavaScript，指示 _你的_ 设备显示这些内容。

那么这与 React 有什么关系呢？React 是一种 UI 编程范例，它允许我将 _要_ 显示的内容（一篇博客文章、一个注册表单，甚至整个应用程序）分解成称为 _组件_ 的独立部分，并像乐高积木一样将它们组合起来。我假设你已经了解并喜欢组件；请查看 [react.dev](https://react.dev) 获取入门介绍。

组件是代码，而这些代码必须在某个地方运行。但是等等——它们应该在 _谁的_ 计算机上运行？应该在你的计算机上运行吗？还是在我的计算机上运行？

让我们为每一方都辩护一下。

---

首先，我将论证组件应该在 _你的_ 计算机上运行。

这是一个简单的计数器按钮，用于演示交互性。点击几次试试！

```js
<Counter />
```

```js eval
<p>
    <Counter />
</p>
```

假设这个组件的 JavaScript 代码已经加载完毕，数字将会增加。请注意，它在按下时是 _瞬间_ 增加的。没有延迟。无需等待服务器。无需下载任何额外的数据。

这之所以可能，是因为这个组件的代码正在 _你的_ 计算机上运行：

```js
import { useState } from "react";

export function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button
      className="dark:color-white rounded-lg bg-purple-700 px-2 py-1 font-sans font-semibold text-white focus:ring active:bg-purple-600"
      onClick={() => setCount(count + 1)}
    >
            你点击了我 {count} 次    {" "}
    </button>
  );
}
```

这里，`count` 是一段 _客户端状态_——你计算机内存中的一小部分信息，每次你按下按钮时都会更新。**我不知道你将要按下按钮多少次**，所以我无法在 _我的_ 计算机上预测和准备所有可能的输出。我最多敢在我的计算机上准备的是 _初始_ 渲染输出（“你点击了我 0 次”），并将其作为 HTML 发送。但是从那时起，_你的计算机必须接管_ 运行这段代码。

你可能会争辩说，在你的计算机上运行这段代码 _仍然_ 不是必要的。也许我可以让它在我的服务器上运行呢？每当你按下按钮时，你的计算机可以向我的服务器请求下一个渲染输出。在所有这些客户端 JavaScript 框架出现之前，网站不就是这样工作的吗？

当用户 _期望_ 有一点延迟时，例如点击链接时，向服务器请求一个新的 UI 效果很好。当用户知道他们正在导航到你的应用程序中的 _某个不同的地方_ 时，他们会等待。然而，任何直接操作（例如拖动滑块、切换标签、在帖子编辑器中输入内容、点击“喜欢”按钮、滑动卡片、悬停菜单、拖动图表等等）如果不能可靠地提供至少 _一些_ 即时反馈，就会感觉很糟糕。

这个原则并非严格意义上的技术问题——它来自日常生活中的直觉。例如，你不会期望电梯按钮能立即带你到下一层。但是当你推门把手时，你 _确实_ 期望它能直接跟随你手的动作，否则会感觉卡住了。事实上，即使是电梯按钮，你也会期望至少 _一些_ 即时反馈：它应该能感受到你手的压力。然后它应该亮起来以确认你的按下。

**当你构建用户界面时，你需要能够以 _保证_ 的低延迟和 _零_ 网络往返来响应至少一些交互。**

你可能已经看到 React 的心智模型被描述为一种等式：_UI 是状态的函数_，或者 `UI = f(state)`。这并不意味着你的 UI 代码必须是一个接受状态作为参数的单一函数；它只是意味着当前状态决定了 UI。当状态改变时，UI 需要重新计算。由于状态“存在”于你的计算机上，因此计算 UI 的代码（你的组件）也必须在你的计算机上运行。

或者，这个论点是这样认为的。

---

接下来，我将提出相反的观点——组件应该在 _我的_ 计算机上运行。

这是来自本博客的另一篇文章的预览卡片：

```js
<PostPreview slug="a-chain-reaction" />
```

```js eval
<div className="mb-8">
    <PostPreview slug="a-chain-reaction" />
</div>
```

来自 _这个_ 页面的组件如何知道 _那个_ 页面上的字数？

如果你检查“网络”选项卡，你会看到没有额外的请求。我并没有从 GitHub 下载整篇博客文章来计算其中的字数。我也不会将该博客文章的内容嵌入到此页面上。我也没有调用任何 API 来计算字数。而且我肯定没有自己数过那些字。

那么这个组件是如何工作的呢？

```js
import { readFile } from "fs/promises";
import matter from "gray-matter";

export async function PostPreview({ slug }) {
  const fileContent = await readFile("./public/" + slug + "/index.md", "utf8");
  const { data, content } = matter(fileContent);
  const wordCount = content.split(" ").filter(Boolean).length;

  return (
    <section className="rounded-md bg-black/5 p-2">
           {" "}
      <h5 className="font-bold">
               {" "}
        <a href={"/" + slug} target="_blank">
                    {data.title}       {" "}
        </a>
             {" "}
      </h5>
            <i>{wordCount} 字</i>   {" "}
    </section>
  );
}
```

这个组件在 _我的_ 计算机上运行。当我想读取一个文件时，我使用 `fs.readFile` 读取它。当我想解析它的 Markdown 头部时，我使用 `gray-matter` 解析它。当我想计算字数时，我分割文本并计算它们。**我不需要做任何额外的事情，因为我的代码运行在 _数据所在的位置_。**

假设我想列出我博客上的 _所有_ 文章及其字数。

很简单：

```js
<PostList />
```

```js eval
<PostList />
```

我只需要为每个帖子文件夹渲染一个 `<PostPreview />`：

```js
import { readdir } from "fs/promises";
import { PostPreview } from "./post-preview";

export async function PostList() {
  const entries = await readdir("./public/", { withFileTypes: true });
  const dirs = entries.filter((entry) => entry.isDirectory());
  return (
    <div className="mb-4 flex h-72 flex-col gap-2 overflow-scroll font-sans">
           {" "}
      {dirs.map((dir) => (
        <PostPreview key={dir.name} slug={dir.name} />
      ))}
         {" "}
    </div>
  );
}
```

所有这些代码都不需要在你的计算机上运行——事实上 _它也不能_，因为你的计算机没有我的文件。让我们检查一下这段代码 _何时_ 运行的：

```js
<p className="text-purple-500 font-bold">  {new Date().toString()}</p>
```

```js eval
<p className="text-purple-500 font-bold">  {new Date().toString()}</p>
```

啊哈——这正是我上次将我的博客部署到我的静态网站托管服务的时间！我的组件在构建过程中运行，因此它们可以完全访问我的帖子。

**让我的组件靠近它们的数据源运行，可以使它们在将任何信息发送到你的设备之前读取自己的数据并对其进行预处理。**

当你加载此页面时，已经没有 `<PostList>` 和 `<PostPreview>`，没有 `fileContent` 和 `dirs`，没有 `fs` 和 `gray-matter` 了。相反，只有一个 `<div>`，里面有几个 `<section>`，每个 `<section>` 里面都有 `<a>` 和 `<i>`。你的设备只接收到 _它实际需要显示的 UI_（渲染后的帖子标题、链接 URL 和帖子字数），而不是你的组件用来计算该 UI 的 _完整的原始数据_（实际的帖子）。

使用这种心智模型，_UI 是服务器数据的函数_，或者 `UI = f(data)`。该数据只存在于 _我的_ 设备上，所以组件应该在那里运行。

或者，这个论点是这样认为的。

---

UI 由组件构成，但我们提出了两种截然不同的愿景：

- `UI = f(state)`，其中 `state` 是客户端状态，而 `f` 在客户端运行。这种方法允许编写像 `<Counter />` 这样具有即时交互性的组件。（在这里，`f` 也可能在服务器端使用初始状态运行以生成 HTML。）
- `UI = f(data)`，其中 `data` 是服务器端数据，而 `f` 仅在服务器端运行。这种方法允许编写像 `<PostPreview />` 这样处理数据的组件。（在这里，`f` 绝对只在服务器端运行。构建时算作“服务器”。）

如果我们抛开熟悉度偏差，这两种方法在它们各自擅长的方面都很有说服力。不幸的是，这些愿景 _似乎_ 是相互不兼容的。

如果我们想要允许像 `<Counter />` 所需的即时交互性，我们 _必须_ 在客户端运行组件。但是像 `<PostPreview />` 这样的组件 _原则上_ 不能在客户端运行，因为它们使用像 `readFile` 这样的服务器端专用 API。（这就是它们的全部意义！否则我们不妨在客户端运行它们。）

好的，如果我们改为在服务器上运行所有组件呢？但是在服务器上，像 `<Counter />` 这样的组件只能渲染它们的 _初始_ 状态。服务器不知道它们的 _当前_ 状态，并且在服务器和客户端之间传递该状态太慢（除非它很小，比如一个 URL），甚至并非总是可行的（例如，我的博客的服务器代码只在部署时运行，所以你不能“传递”任何东西给它）。

再次，看起来我们必须在两种不同的 React 之间做出选择：

- 允许我们编写 `<Counter />` 的“客户端” `UI = f(state)` 范例。
- 允许我们编写 `<PostPreview />` 的“服务器端” `UI = f(data)` 范例。

但在实践中，真正的“公式”更接近于 `UI = f(data, state)`。如果你没有 `data` 或没有 `state`，它会推广到这些情况。但理想情况下，我更希望我的编程范例能够 _同时处理这两种情况_，而无需选择另一种抽象，我知道至少有一些人也会这样想。

那么，要解决的问题是如何在我们两个非常不同的编程环境之间拆分我们的“`f`”。这甚至可能吗？回想一下，我们不是在谈论一些名为 `f` 的实际函数——在这里，`f` 代表我们所有的组件。

有没有什么方法可以以保留 React 优点的形式在你的计算机和我的计算机之间拆分组件？我们能否组合和嵌套来自两个不同环境的组件？这将如何工作？

这 _应该_ 如何工作？

好好想想，下次我们再交流一下想法。
